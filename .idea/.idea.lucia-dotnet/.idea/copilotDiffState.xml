<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/lucia.HomeAssistant.SourceGenerator/HomeAssistantApiGenerator.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/lucia.HomeAssistant.SourceGenerator/HomeAssistantApiGenerator.cs" />
              <option name="originalContent" value="using Microsoft.CodeAnalysis;&#10;using Microsoft.CodeAnalysis.CSharp;&#10;using System.Text;&#10;&#10;namespace lucia.HomeAssistant.SourceGenerator;&#10;&#10;[Generator]&#10;public class HomeAssistantApiGenerator : ISourceGenerator&#10;{&#10;    public void Initialize(GeneratorInitializationContext context)&#10;    {&#10;        context.RegisterForSyntaxNotifications(() =&gt; new SyntaxReceiver());&#10;    }&#10;&#10;    public void Execute(GeneratorExecutionContext context)&#10;    {&#10;        if (context.SyntaxReceiver is not SyntaxReceiver receiver)&#10;            return;&#10;&#10;        foreach (var candidateClass in receiver.CandidateClasses)&#10;        {&#10;            var model = context.Compilation.GetSemanticModel(candidateClass.SyntaxTree);&#10;            var classSymbol = model.GetDeclaredSymbol(candidateClass);&#10;            &#10;            if (classSymbol == null)&#10;                continue;&#10;&#10;            var attribute = classSymbol.GetAttributes()&#10;                .FirstOrDefault(a =&gt; a.AttributeClass?.Name == &quot;HomeAssistantApiAttribute&quot; || &#10;                                   a.AttributeClass?.ToDisplayString().Contains(&quot;HomeAssistantApiAttribute&quot;) == true);&#10;&#10;            if (attribute == null)&#10;                continue;&#10;&#10;            var namespaceName = classSymbol.ContainingNamespace.ToDisplayString();&#10;            var className = classSymbol.Name;&#10;&#10;            var source = GenerateApiClient(namespaceName, className, attribute);&#10;            context.AddSource($&quot;{className}.g.cs&quot;, source);&#10;        }&#10;    }&#10;&#10;    private string GenerateApiClient(string namespaceName, string className, AttributeData attribute)&#10;    {&#10;        var configSectionName = GetAttributeValue(attribute, &quot;ConfigSectionName&quot;, &quot;HomeAssistant&quot;);&#10;        var endpoints = HomeAssistantEndpoints.GetEndpoints();&#10;        &#10;        var source = $@&quot;#nullable enable&#10;using System;&#10;using System.Collections.Generic;&#10;using System.Net.Http;&#10;using System.Net.Http.Json;&#10;using System.Text;&#10;using System.Text.Json;&#10;using System.Threading;&#10;using System.Threading.Tasks;&#10;using Microsoft.Extensions.Options;&#10;using lucia.HomeAssistant.Configuration;&#10;using lucia.HomeAssistant.Models;&#10;&#10;namespace {namespaceName}&#10;{{&#10;    public partial class {className}&#10;    {{&#10;        private readonly HttpClient _httpClient;&#10;        private readonly HomeAssistantOptions _options;&#10;        private readonly JsonSerializerOptions _jsonOptions;&#10;&#10;        public {className}(HttpClient httpClient, IOptions&lt;HomeAssistantOptions&gt; options)&#10;        {{&#10;            _httpClient = httpClient;&#10;            _options = options.Value;&#10;            _jsonOptions = new JsonSerializerOptions&#10;            {{&#10;                PropertyNamingPolicy = JsonNamingPolicy.SnakeCaseLower&#10;            }};&#10;&#10;            ConfigureHttpClient();&#10;        }}&#10;&#10;        private void ConfigureHttpClient()&#10;        {{&#10;            _httpClient.BaseAddress = new Uri(_options.BaseUrl.TrimEnd('/'));&#10;            _httpClient.DefaultRequestHeaders.Add(&quot;&quot;Authorization&quot;&quot;, $&quot;&quot;Bearer {{_options.AccessToken}}&quot;&quot;);&#10;            _httpClient.DefaultRequestHeaders.Add(&quot;&quot;Accept&quot;&quot;, &quot;&quot;application/json&quot;&quot;);&#10;            _httpClient.Timeout = TimeSpan.FromSeconds(_options.TimeoutSeconds);&#10;        }}&#10;&#10;        // Generated API Methods&#10;{GenerateEndpointMethods(endpoints)}&#10;&#10;        // Helper Methods&#10;        private string BuildQueryString(Dictionary&lt;string, object?&gt; parameters)&#10;        {{&#10;            var query = new List&lt;string&gt;();&#10;            foreach (var param in parameters)&#10;            {{&#10;                if (param.Value != null)&#10;                {{&#10;                    query.Add($&quot;&quot;{{param.Key}}={{Uri.EscapeDataString(param.Value.ToString())}}&quot;&quot;);&#10;                }}&#10;            }}&#10;            return query.Count &gt; 0 ? &quot;&quot;?&quot;&quot; + string.Join(&quot;&quot;&amp;&quot;&quot;, query) : &quot;&quot;&quot;&quot;;&#10;        }}&#10;    }}&#10;}}&quot;;&#10;&#10;        return source;&#10;    }&#10;&#10;    private string GenerateEndpointMethods(List&lt;OpenApiEndpoint&gt; endpoints)&#10;    {&#10;        var methods = new StringBuilder();&#10;        &#10;        foreach (var endpoint in endpoints)&#10;        {&#10;            methods.AppendLine(GenerateEndpointMethod(endpoint));&#10;        }&#10;        &#10;        return methods.ToString();&#10;    }&#10;&#10;    private string GenerateEndpointMethod(OpenApiEndpoint endpoint)&#10;    {&#10;        var methodName = endpoint.OperationId;&#10;        var pathParams = endpoint.Parameters.Where(p =&gt; p.Location == &quot;path&quot;).ToList();&#10;        var queryParams = endpoint.Parameters.Where(p =&gt; p.Location == &quot;query&quot;).ToList();&#10;        var hasRequestBody = !string.IsNullOrEmpty(endpoint.RequestBodyType) &amp;&amp; endpoint.HttpMethod.ToUpper() == &quot;POST&quot;;&#10;        &#10;        // Build parameter list&#10;        var parameters = new List&lt;string&gt;();&#10;        &#10;        // Add path parameters&#10;        foreach (var param in pathParams)&#10;        {&#10;            parameters.Add($&quot;{GetCSharpType(param.Type)} {param.Name}&quot;);&#10;        }&#10;        &#10;        // Add request body if needed&#10;        if (hasRequestBody)&#10;        {&#10;            parameters.Add($&quot;{endpoint.RequestBodyType}? request = null&quot;);&#10;        }&#10;        &#10;        // Add query parameters&#10;        foreach (var param in queryParams)&#10;        {&#10;            var paramType = GetCSharpType(param.Type);&#10;            if (!param.IsRequired)&#10;            {&#10;                paramType += &quot;?&quot;;&#10;            }&#10;            parameters.Add($&quot;{paramType} {param.Name} = default&quot;);&#10;        }&#10;        &#10;        parameters.Add(&quot;CancellationToken cancellationToken = default&quot;);&#10;        &#10;        var parameterList = string.Join(&quot;, &quot;, parameters);&#10;        &#10;        // Build path with parameters&#10;        var path = endpoint.Path;&#10;        foreach (var param in pathParams)&#10;        {&#10;            path = path.Replace($&quot;{{{param.Name}}}&quot;, $&quot;{{Uri.EscapeDataString({param.Name})}}&quot;);&#10;        }&#10;        &#10;        // Build query string logic&#10;        var queryStringBuilder = new StringBuilder();&#10;        if (queryParams.Any())&#10;        {&#10;            queryStringBuilder.AppendLine(&quot;            var queryParams = new Dictionary&lt;string, object?&gt;();&quot;);&#10;            foreach (var param in queryParams)&#10;            {&#10;                queryStringBuilder.AppendLine($&quot;            if ({param.Name} != default) queryParams[\&quot;{param.Name}\&quot;] = {param.Name};&quot;);&#10;            }&#10;            queryStringBuilder.AppendLine(&quot;            var queryString = BuildQueryString(queryParams);&quot;);&#10;        }&#10;        &#10;        // Generate method body based on HTTP method&#10;        var methodBody = endpoint.HttpMethod.ToUpper() switch&#10;        {&#10;            &quot;GET&quot; =&gt; GenerateGetMethodBody(endpoint, path, queryParams.Any()),&#10;            &quot;POST&quot; =&gt; GeneratePostMethodBody(endpoint, path, hasRequestBody, queryParams.Any()),&#10;            _ =&gt; throw new System.NotSupportedException($&quot;HTTP method {endpoint.HttpMethod} not supported&quot;)&#10;        };&#10;        &#10;        return $@&quot;&#10;        /// &lt;summary&gt;&#10;        /// {endpoint.Description}&#10;        /// &lt;/summary&gt;&#10;        public async Task&lt;{endpoint.ResponseType}&gt; {methodName}Async({parameterList})&#10;        {{&#10;{queryStringBuilder}&#10;{methodBody}&#10;        }}&quot;;&#10;    }&#10;&#10;    private string GenerateGetMethodBody(OpenApiEndpoint endpoint, string path, bool hasQueryParams)&#10;    {&#10;        var url = hasQueryParams ? $&quot;$\&quot;{path}\&quot; + queryString&quot; : $&quot;$\&quot;{path}\&quot;&quot;;&#10;        &#10;        if (endpoint.ResponseType == &quot;byte[]&quot;)&#10;        {&#10;            return $@&quot;            var response = await _httpClient.GetAsync({url}, cancellationToken);&#10;            response.EnsureSuccessStatusCode();&#10;            return await response.Content.ReadAsByteArrayAsync();&quot;;&#10;        }&#10;        else if (endpoint.ResponseType == &quot;string&quot;)&#10;        {&#10;            return $@&quot;            var response = await _httpClient.GetAsync({url}, cancellationToken);&#10;            response.EnsureSuccessStatusCode();&#10;            return await response.Content.ReadAsStringAsync();&quot;;&#10;        }&#10;        else if (endpoint.ResponseType.EndsWith(&quot;[]&quot;))&#10;        {&#10;            var elementType = endpoint.ResponseType.TrimEnd('[', ']');&#10;            return $@&quot;            var result = await _httpClient.GetFromJsonAsync&lt;{elementType}[]&gt;({url}, _jsonOptions, cancellationToken);&#10;            return result ?? Array.Empty&lt;{elementType}&gt;();&quot;;&#10;        }&#10;        else&#10;        {&#10;            // Special handling for GetState endpoint - return null on 404&#10;            if (endpoint.OperationId == &quot;GetState&quot;)&#10;            {&#10;                return $@&quot;            try&#10;            {{&#10;                var result = await _httpClient.GetFromJsonAsync&lt;{endpoint.ResponseType}&gt;({url}, _jsonOptions, cancellationToken);&#10;                return result ?? throw new InvalidOperationException(&quot;&quot;Failed to deserialize response&quot;&quot;);&#10;            }}&#10;            catch (HttpRequestException ex) when (ex.Message.Contains(&quot;&quot;404&quot;&quot;))&#10;            {{&#10;                return null;&#10;            }}&quot;;&#10;            }&#10;            else&#10;            {&#10;                return $@&quot;            var result = await _httpClient.GetFromJsonAsync&lt;{endpoint.ResponseType}&gt;({url}, _jsonOptions, cancellationToken);&#10;            return result ?? throw new InvalidOperationException(&quot;&quot;Failed to deserialize response&quot;&quot;);&quot;;&#10;            }&#10;        }&#10;    }&#10;&#10;    private string GeneratePostMethodBody(OpenApiEndpoint endpoint, string path, bool hasRequestBody, bool hasQueryParams)&#10;    {&#10;        var url = hasQueryParams ? $&quot;$\&quot;{path}\&quot; + queryString&quot; : $&quot;$\&quot;{path}\&quot;&quot;;&#10;        &#10;        var requestBodySerialization = hasRequestBody &#10;            ? &quot;JsonSerializer.Serialize(request, _jsonOptions)&quot; &#10;            : &quot;\&quot;{}\&quot;&quot;;&#10;        &#10;        if (endpoint.ResponseType == &quot;string&quot;)&#10;        {&#10;            return $@&quot;            var json = {requestBodySerialization};&#10;            var content = new StringContent(json, Encoding.UTF8, &quot;&quot;application/json&quot;&quot;);&#10;            var response = await _httpClient.PostAsync({url}, content, cancellationToken);&#10;            response.EnsureSuccessStatusCode();&#10;            return await response.Content.ReadAsStringAsync();&quot;;&#10;        }&#10;        else&#10;        {&#10;            return $@&quot;            var json = {requestBodySerialization};&#10;            var content = new StringContent(json, Encoding.UTF8, &quot;&quot;application/json&quot;&quot;);&#10;            var response = await _httpClient.PostAsync({url}, content, cancellationToken);&#10;            response.EnsureSuccessStatusCode();&#10;            var result = await response.Content.ReadFromJsonAsync&lt;{endpoint.ResponseType}&gt;(_jsonOptions, cancellationToken);&#10;            return result ?? throw new InvalidOperationException(&quot;&quot;Failed to deserialize response&quot;&quot;);&quot;;&#10;        }&#10;    }&#10;&#10;    private string GetCSharpType(string type)&#10;    {&#10;        return type switch&#10;        {&#10;            &quot;string&quot; =&gt; &quot;string&quot;,&#10;            &quot;bool&quot; =&gt; &quot;bool&quot;,&#10;            &quot;int&quot; =&gt; &quot;int&quot;,&#10;            &quot;long&quot; =&gt; &quot;long&quot;,&#10;            &quot;double&quot; =&gt; &quot;double&quot;,&#10;            &quot;float&quot; =&gt; &quot;float&quot;,&#10;            &quot;DateTime&quot; =&gt; &quot;DateTime&quot;,&#10;            _ =&gt; &quot;string&quot;&#10;        };&#10;    }&#10;&#10;    private string GetAttributeValue(AttributeData attribute, string propertyName, string defaultValue)&#10;    {&#10;        var namedArg = attribute.NamedArguments.FirstOrDefault(na =&gt; na.Key == propertyName);&#10;        return namedArg.Value.Value?.ToString() ?? defaultValue;&#10;    }&#10;}" />
              <option name="updatedContent" value="using Microsoft.CodeAnalysis;&#10;using Microsoft.CodeAnalysis.CSharp;&#10;using Microsoft.CodeAnalysis.CSharp.Syntax;&#10;using System.Text;&#10;&#10;namespace lucia.HomeAssistant.SourceGenerator;&#10;&#10;[Generator]&#10;public class HomeAssistantApiGenerator : IIncrementalGenerator&#10;{&#10;    public void Initialize(IncrementalGeneratorInitializationContext context)&#10;    {&#10;        // Register the syntax provider to find candidate classes with attributes&#10;        IncrementalValuesProvider&lt;ClassDeclarationSyntax&gt; classDeclarations = context.SyntaxProvider&#10;            .CreateSyntaxProvider(&#10;                predicate: static (s, _) =&gt; IsSyntaxTargetForGeneration(s),&#10;                transform: static (ctx, _) =&gt; GetClassDeclaration(ctx))&#10;            .Where(static m =&gt; m is not null)!;&#10;&#10;        // Register source output action&#10;        context.RegisterSourceOutput(&#10;            classDeclarations.Combine(context.CompilationProvider),&#10;            static (spc, source) =&gt; Execute(source.Left, source.Right, spc));&#10;    }&#10;&#10;    private static bool IsSyntaxTargetForGeneration(SyntaxNode node)&#10;    {&#10;        // Only consider class declarations with attributes&#10;        return node is ClassDeclarationSyntax classDecl &amp;&amp; classDecl.AttributeLists.Count &gt; 0;&#10;    }&#10;&#10;    private static ClassDeclarationSyntax GetClassDeclaration(GeneratorSyntaxContext context)&#10;    {&#10;        var classDeclaration = (ClassDeclarationSyntax)context.Node;&#10;        return classDeclaration;&#10;    }&#10;&#10;    private static void Execute(ClassDeclarationSyntax classDeclaration, Compilation compilation, SourceProductionContext context)&#10;    {&#10;        // Get the semantic model for the class declaration&#10;        var semanticModel = compilation.GetSemanticModel(classDeclaration.SyntaxTree);&#10;        var classSymbol = semanticModel.GetDeclaredSymbol(classDeclaration) as INamedTypeSymbol;&#10;        &#10;        if (classSymbol == null)&#10;            return;&#10;&#10;        var attribute = classSymbol.GetAttributes()&#10;            .FirstOrDefault(a =&gt; a.AttributeClass?.Name == &quot;HomeAssistantApiAttribute&quot; || &#10;                               a.AttributeClass?.ToDisplayString().Contains(&quot;HomeAssistantApiAttribute&quot;) == true);&#10;&#10;        if (attribute == null)&#10;            return;&#10;&#10;        var namespaceName = classSymbol.ContainingNamespace.ToDisplayString();&#10;        var className = classSymbol.Name;&#10;&#10;        var source = GenerateApiClient(namespaceName, className, attribute);&#10;        context.AddSource($&quot;{className}.g.cs&quot;, source);&#10;    }&#10;&#10;    private static string GenerateApiClient(string namespaceName, string className, AttributeData attribute)&#10;    {&#10;        var configSectionName = GetAttributeValue(attribute, &quot;ConfigSectionName&quot;, &quot;HomeAssistant&quot;);&#10;        var endpoints = HomeAssistantEndpoints.GetEndpoints();&#10;        &#10;        var source = $@&quot;#nullable enable&#10;using System;&#10;using System.Collections.Generic;&#10;using System.Net.Http;&#10;using System.Net.Http.Json;&#10;using System.Text;&#10;using System.Text.Json;&#10;using System.Threading;&#10;using System.Threading.Tasks;&#10;using Microsoft.Extensions.Options;&#10;using lucia.HomeAssistant.Configuration;&#10;using lucia.HomeAssistant.Models;&#10;&#10;namespace {namespaceName}&#10;{{&#10;    public partial class {className}&#10;    {{&#10;        private readonly HttpClient _httpClient;&#10;        private readonly HomeAssistantOptions _options;&#10;        private readonly JsonSerializerOptions _jsonOptions;&#10;&#10;        public {className}(HttpClient httpClient, IOptions&lt;HomeAssistantOptions&gt; options)&#10;        {{&#10;            _httpClient = httpClient;&#10;            _options = options.Value;&#10;            _jsonOptions = new JsonSerializerOptions&#10;            {{&#10;                PropertyNamingPolicy = JsonNamingPolicy.SnakeCaseLower&#10;            }};&#10;&#10;            ConfigureHttpClient();&#10;        }}&#10;&#10;        private void ConfigureHttpClient()&#10;        {{&#10;            _httpClient.BaseAddress = new Uri(_options.BaseUrl.TrimEnd('/'));&#10;            _httpClient.DefaultRequestHeaders.Add(&quot;&quot;Authorization&quot;&quot;, $&quot;&quot;Bearer {{_options.AccessToken}}&quot;&quot;);&#10;            _httpClient.DefaultRequestHeaders.Add(&quot;&quot;Accept&quot;&quot;, &quot;&quot;application/json&quot;&quot;);&#10;            _httpClient.Timeout = TimeSpan.FromSeconds(_options.TimeoutSeconds);&#10;        }}&#10;&#10;        // Generated API Methods&#10;{GenerateEndpointMethods(endpoints)}&#10;&#10;        // Helper Methods&#10;        private string BuildQueryString(Dictionary&lt;string, object?&gt; parameters)&#10;        {{&#10;            var query = new List&lt;string&gt;();&#10;            foreach (var param in parameters)&#10;            {{&#10;                if (param.Value != null)&#10;                {{&#10;                    query.Add($&quot;&quot;{{param.Key}}={{Uri.EscapeDataString(param.Value.ToString())}}&quot;&quot;);&#10;                }}&#10;            }}&#10;            return query.Count &gt; 0 ? &quot;&quot;?&quot;&quot; + string.Join(&quot;&quot;&amp;&quot;&quot;, query) : &quot;&quot;&quot;&quot;;&#10;        }}&#10;    }}&#10;}}&quot;;&#10;&#10;        return source;&#10;    }&#10;&#10;    private static string GenerateEndpointMethods(List&lt;OpenApiEndpoint&gt; endpoints)&#10;    {&#10;        var methods = new StringBuilder();&#10;        &#10;        foreach (var endpoint in endpoints)&#10;        {&#10;            methods.AppendLine(GenerateEndpointMethod(endpoint));&#10;        }&#10;        &#10;        return methods.ToString();&#10;    }&#10;&#10;    private static string GenerateEndpointMethod(OpenApiEndpoint endpoint)&#10;    {&#10;        var methodName = endpoint.OperationId;&#10;        var pathParams = endpoint.Parameters.Where(p =&gt; p.Location == &quot;path&quot;).ToList();&#10;        var queryParams = endpoint.Parameters.Where(p =&gt; p.Location == &quot;query&quot;).ToList();&#10;        var hasRequestBody = !string.IsNullOrEmpty(endpoint.RequestBodyType) &amp;&amp; endpoint.HttpMethod.ToUpper() == &quot;POST&quot;;&#10;        &#10;        // Build parameter list&#10;        var parameters = new List&lt;string&gt;();&#10;        &#10;        // Add path parameters&#10;        foreach (var param in pathParams)&#10;        {&#10;            parameters.Add($&quot;{GetCSharpType(param.Type)} {param.Name}&quot;);&#10;        }&#10;        &#10;        // Add request body if needed&#10;        if (hasRequestBody)&#10;        {&#10;            parameters.Add($&quot;{endpoint.RequestBodyType}? request = null&quot;);&#10;        }&#10;        &#10;        // Add query parameters&#10;        foreach (var param in queryParams)&#10;        {&#10;            var paramType = GetCSharpType(param.Type);&#10;            if (!param.IsRequired)&#10;            {&#10;                paramType += &quot;?&quot;;&#10;            }&#10;            parameters.Add($&quot;{paramType} {param.Name} = default&quot;);&#10;        }&#10;        &#10;        parameters.Add(&quot;CancellationToken cancellationToken = default&quot;);&#10;        &#10;        var parameterList = string.Join(&quot;, &quot;, parameters);&#10;        &#10;        // Build path with parameters&#10;        var path = endpoint.Path;&#10;        foreach (var param in pathParams)&#10;        {&#10;            path = path.Replace($&quot;{{{param.Name}}}&quot;, $&quot;{{Uri.EscapeDataString({param.Name})}}&quot;);&#10;        }&#10;        &#10;        // Build query string logic&#10;        var queryStringBuilder = new StringBuilder();&#10;        if (queryParams.Any())&#10;        {&#10;            queryStringBuilder.AppendLine(&quot;            var queryParams = new Dictionary&lt;string, object?&gt;();&quot;);&#10;            foreach (var param in queryParams)&#10;            {&#10;                queryStringBuilder.AppendLine($&quot;            if ({param.Name} != default) queryParams[\&quot;{param.Name}\&quot;] = {param.Name};&quot;);&#10;            }&#10;            queryStringBuilder.AppendLine(&quot;            var queryString = BuildQueryString(queryParams);&quot;);&#10;        }&#10;        &#10;        // Generate method body based on HTTP method&#10;        var methodBody = endpoint.HttpMethod.ToUpper() switch&#10;        {&#10;            &quot;GET&quot; =&gt; GenerateGetMethodBody(endpoint, path, queryParams.Any()),&#10;            &quot;POST&quot; =&gt; GeneratePostMethodBody(endpoint, path, hasRequestBody, queryParams.Any()),&#10;            _ =&gt; throw new System.NotSupportedException($&quot;HTTP method {endpoint.HttpMethod} not supported&quot;)&#10;        };&#10;        &#10;        return $@&quot;&#10;        /// &lt;summary&gt;&#10;        /// {endpoint.Description}&#10;        /// &lt;/summary&gt;&#10;        public async Task&lt;{endpoint.ResponseType}&gt; {methodName}Async({parameterList})&#10;        {{&#10;{queryStringBuilder}&#10;{methodBody}&#10;        }}&quot;;&#10;    }&#10;&#10;    private static string GenerateGetMethodBody(OpenApiEndpoint endpoint, string path, bool hasQueryParams)&#10;    {&#10;        var url = hasQueryParams ? $&quot;$\&quot;{path}\&quot; + queryString&quot; : $&quot;$\&quot;{path}\&quot;&quot;;&#10;        &#10;        if (endpoint.ResponseType == &quot;byte[]&quot;)&#10;        {&#10;            return $@&quot;            var response = await _httpClient.GetAsync({url}, cancellationToken);&#10;            response.EnsureSuccessStatusCode();&#10;            return await response.Content.ReadAsByteArrayAsync();&quot;;&#10;        }&#10;        else if (endpoint.ResponseType == &quot;string&quot;)&#10;        {&#10;            return $@&quot;            var response = await _httpClient.GetAsync({url}, cancellationToken);&#10;            response.EnsureSuccessStatusCode();&#10;            return await response.Content.ReadAsStringAsync();&quot;;&#10;        }&#10;        else if (endpoint.ResponseType.EndsWith(&quot;[]&quot;))&#10;        {&#10;            var elementType = endpoint.ResponseType.TrimEnd('[', ']');&#10;            return $@&quot;            var result = await _httpClient.GetFromJsonAsync&lt;{elementType}[]&gt;({url}, _jsonOptions, cancellationToken);&#10;            return result ?? Array.Empty&lt;{elementType}&gt;();&quot;;&#10;        }&#10;        else&#10;        {&#10;            // Special handling for GetState endpoint - return null on 404&#10;            if (endpoint.OperationId == &quot;GetState&quot;)&#10;            {&#10;                return $@&quot;            try&#10;            {{&#10;                var result = await _httpClient.GetFromJsonAsync&lt;{endpoint.ResponseType}&gt;({url}, _jsonOptions, cancellationToken);&#10;                return result ?? throw new InvalidOperationException(&quot;&quot;Failed to deserialize response&quot;&quot;);&#10;            }}&#10;            catch (HttpRequestException ex) when (ex.Message.Contains(&quot;&quot;404&quot;&quot;))&#10;            {{&#10;                return null;&#10;            }}&quot;;&#10;            }&#10;            else&#10;            {&#10;                return $@&quot;            var result = await _httpClient.GetFromJsonAsync&lt;{endpoint.ResponseType}&gt;({url}, _jsonOptions, cancellationToken);&#10;            return result ?? throw new InvalidOperationException(&quot;&quot;Failed to deserialize response&quot;&quot;);&quot;;&#10;            }&#10;        }&#10;    }&#10;&#10;    private static string GeneratePostMethodBody(OpenApiEndpoint endpoint, string path, bool hasRequestBody, bool hasQueryParams)&#10;    {&#10;        var url = hasQueryParams ? $&quot;$\&quot;{path}\&quot; + queryString&quot; : $&quot;$\&quot;{path}\&quot;&quot;;&#10;        &#10;        var requestBodySerialization = hasRequestBody &#10;            ? &quot;JsonSerializer.Serialize(request, _jsonOptions)&quot; &#10;            : &quot;\&quot;{}\&quot;&quot;;&#10;        &#10;        if (endpoint.ResponseType == &quot;string&quot;)&#10;        {&#10;            return $@&quot;            var json = {requestBodySerialization};&#10;            var content = new StringContent(json, Encoding.UTF8, &quot;&quot;application/json&quot;&quot;);&#10;            var response = await _httpClient.PostAsync({url}, content, cancellationToken);&#10;            response.EnsureSuccessStatusCode();&#10;            return await response.Content.ReadAsStringAsync();&quot;;&#10;        }&#10;        else&#10;        {&#10;            return $@&quot;            var json = {requestBodySerialization};&#10;            var content = new StringContent(json, Encoding.UTF8, &quot;&quot;application/json&quot;&quot;);&#10;            var response = await _httpClient.PostAsync({url}, content, cancellationToken);&#10;            response.EnsureSuccessStatusCode();&#10;            var result = await response.Content.ReadFromJsonAsync&lt;{endpoint.ResponseType}&gt;(_jsonOptions, cancellationToken);&#10;            return result ?? throw new InvalidOperationException(&quot;&quot;Failed to deserialize response&quot;&quot;);&quot;;&#10;        }&#10;    }&#10;&#10;    private static string GetCSharpType(string type)&#10;    {&#10;        return type switch&#10;        {&#10;            &quot;string&quot; =&gt; &quot;string&quot;,&#10;            &quot;bool&quot; =&gt; &quot;bool&quot;,&#10;            &quot;int&quot; =&gt; &quot;int&quot;,&#10;            &quot;long&quot; =&gt; &quot;long&quot;,&#10;            &quot;double&quot; =&gt; &quot;double&quot;,&#10;            &quot;float&quot; =&gt; &quot;float&quot;,&#10;            &quot;DateTime&quot; =&gt; &quot;DateTime&quot;,&#10;            _ =&gt; &quot;string&quot;&#10;        };&#10;    }&#10;&#10;    private static string GetAttributeValue(AttributeData attribute, string propertyName, string defaultValue)&#10;    {&#10;        var namedArg = attribute.NamedArguments.FirstOrDefault(na =&gt; na.Key == propertyName);&#10;        return namedArg.Value.Value?.ToString() ?? defaultValue;&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>